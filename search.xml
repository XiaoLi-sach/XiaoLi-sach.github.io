<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022.06.14面试复盘</title>
    <url>/2022/06/14/22-06-14%20%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</url>
    <content><![CDATA[<p>1. </p>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>简历</title>
    <url>/2022/06/13/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</url>
    <content><![CDATA[<h3 id="XXX-Web-前端开发工程师"><a href="#XXX-Web-前端开发工程师" class="headerlink" title="XXX - Web 前端开发工程师"></a>XXX - Web 前端开发工程师</h3><hr>
<h4 id="【基本资料】"><a href="#【基本资料】" class="headerlink" title="【基本资料】"></a>【基本资料】</h4><p>姓名： xxx             年龄： 19<br>专业： 计算机应用技术  |   专科    经验： 1 年<br>电话： 17355085786          邮箱： <a href="mailto:&#88;&#105;&#97;&#111;&#x4c;&#x69;&#x5f;&#49;&#x34;&#53;&#x36;&#64;&#111;&#117;&#x74;&#108;&#111;&#111;&#x6b;&#x2e;&#x63;&#x6f;&#109;">&#88;&#105;&#97;&#111;&#x4c;&#x69;&#x5f;&#49;&#x34;&#53;&#x36;&#64;&#111;&#117;&#x74;&#108;&#111;&#111;&#x6b;&#x2e;&#x63;&#x6f;&#109;</a></p>
<h4 id="【专业技能】"><a href="#【专业技能】" class="headerlink" title="【专业技能】"></a>【专业技能】</h4><ul>
<li>熟练使用Vue全家桶, 了解Vue周边生态，能使用TypeScript 进行开发。</li>
<li>熟练使用弹性布局、响应式布局、能够兼容多种浏览器。</li>
<li>熟练使用Less、Sass 等CSS 预编译工具。</li>
<li>熟练使用各种 UI 组件库。</li>
<li>熟练使用axios 异步通信技术。</li>
<li>熟练使用nginx 反向代理实现跨域请求。</li>
<li>熟练使用版本控制系统，如SVN、Git。</li>
<li>有了解过桌面开发框架 electron。</li>
</ul>
<h4 id="【工作经历】"><a href="#【工作经历】" class="headerlink" title="【工作经历】"></a>【工作经历】</h4><ul>
<li><code>2021-07 ~ 2021-05-31</code> 合肥xxxx信息科技有限公司 – 前端开发</li>
</ul>
<h4 id="【项目经历】"><a href="#【项目经历】" class="headerlink" title="【项目经历】"></a>【项目经历】</h4><p><strong>xxx企业官网（B端 + C端）</strong></p>
<p><code>vue</code> <code>nuxt</code> <code>vuex</code> <code>scss</code></p>
<ul>
<li>使用<code>rem</code>和 <code>@media</code>, 基本布局上使用<code>flex</code>, 实现自适应移动端及PC端</li>
<li>使用<code>vue-i18n</code> 实现中英文国家化</li>
<li>使用<code>nuxt</code> 处理SEO等问题</li>
</ul>
<p><strong>xxx集团管理平台（B端）</strong></p>
<p><code>vue</code> <code>element</code> <code>vue-router</code> <code>vuex</code></p>
<ul>
<li>企业面向自己员工的管理， 客户订单的一系列操作</li>
<li>我参与的开发：<ul>
<li>开发框架的基本搭建， 常用<code>utils</code> 的方法封装</li>
<li>封装了一些常用的业务组件</li>
<li>基础模块：用户管理方面, 订单流的相关工作及逻辑上的处理</li>
</ul>
</li>
<li>处理了由引入组件过多导致的首页开屏以及加载缓慢, 时间较长的问题</li>
</ul>
<h4 id="【自我评价】"><a href="#【自我评价】" class="headerlink" title="【自我评价】"></a>【自我评价】</h4><p>有梦想有追求的前端工程师，对新鲜事物有很强的好奇心，不太喜欢老的技术，学习能力强，性格乐<br>观，对工作注重效率，能够根据客户需求提出自己的开发建议，对代码有一定的洁癖。</p>
]]></content>
      <tags>
        <tag>简历</tag>
      </tags>
  </entry>
  <entry>
    <title>学习electron 过程中的收获</title>
    <url>/2022/06/10/%E5%AD%A6%E4%B9%A0electron%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%94%B6%E8%8E%B7/</url>
    <content><![CDATA[<h2 id="近期想点亮更多的前端技术栈，-然后浅学一下electron，-做一下总结"><a href="#近期想点亮更多的前端技术栈，-然后浅学一下electron，-做一下总结" class="headerlink" title="近期想点亮更多的前端技术栈， 然后浅学一下electron， 做一下总结"></a>近期想点亮更多的前端技术栈， 然后浅学一下electron， 做一下总结</h2><hr>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><ol>
<li><p><code>electron</code> 创建的是一个chrome 浏览器</p>
<ul>
<li>自身是一个主进程, 每个浏览的页面是渲染进程</li>
<li>只有一个入口文件</li>
</ul>
</li>
<li></li>
</ol>
]]></content>
      <tags>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title>手写32个js 面试题</title>
    <url>/2022/05/30/%E6%89%8B%E5%86%9932%E4%B8%AAjs%20%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="回顾一下基础的面试题"><a href="#回顾一下基础的面试题" class="headerlink" title="回顾一下基础的面试题"></a>回顾一下基础的面试题</h3><p><code>一些代码放到github上， 可以拉去进行测试验证</code></p>
<ol>
<li><p>数组扁平化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, [<span class="number">5</span>]]]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> temp = list.flat() <span class="comment">// 正常情况下</span></span><br><span class="line"><span class="comment">// 如果数组嵌套过深则</span></span><br><span class="line"><span class="keyword">const</span> temp2 = list.flat(<span class="literal">Infinity</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>数组去重</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 语法较新</span></span><br><span class="line"><span class="keyword">const</span> temp = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(list))</span><br><span class="line"><span class="comment">// 正常我喜欢这么写</span></span><br><span class="line"><span class="keyword">const</span> temp2 = list.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> list.indexOf(item) === index;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问： Array.from 是什么？？</p>
<blockquote>
<p>答：对类似数组或可迭代对象创建一个新的浅拷贝的数组实例</p>
</blockquote>
</blockquote>
</li>
<li><p>手写es6 filter方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.filter = <span class="function"><span class="keyword">function</span> (<span class="params">callback, thisArg</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> result = []</span><br><span class="line">   <span class="keyword">const</span> list = <span class="built_in">Object</span>(<span class="built_in">this</span>)</span><br><span class="line">   <span class="keyword">const</span> len = <span class="built_in">this</span>.length &gt;&gt;&gt; <span class="number">0</span> <span class="comment">// 必须为正整数</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i <span class="keyword">in</span> list) &#123;</span><br><span class="line">         <span class="keyword">if</span> (callback.call(thisArg, list[i], i, list)) &#123;</span><br><span class="line">            result.push(list[i])</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>手写es6 map方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">callback, thisArg</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> result = [];</span><br><span class="line">   <span class="keyword">const</span> list = <span class="built_in">Object</span>(<span class="built_in">this</span>);</span><br><span class="line">   <span class="keyword">const</span> len = <span class="built_in">this</span>.length &gt;&gt;&gt; <span class="number">0</span>; <span class="comment">//  同上</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调用回调， 将新的值传回去</span></span><br><span class="line">      <span class="keyword">if</span> (i <span class="keyword">in</span> list) &#123;</span><br><span class="line">         result[i] = callback.call(thisArg, list[i], i, list)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>手写 function.prototype.call()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>ts基础面试内容</title>
    <url>/2022/05/30/ts%E5%9F%BA%E6%9C%AC%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ul>
<li><p>interface 和 type 的区别</p>
<ul>
<li><p>interface只能声明对象， type的右边可以是任何类型（包括对象在内）</p>
</li>
<li><p>扩展时表现不同</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> test &#123;</span><br><span class="line">    x: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> test2 <span class="keyword">extends</span> test &#123;</span><br><span class="line">    x: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> test = &#123;</span><br><span class="line">    x: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> test1 = &#123;</span><br><span class="line">    x: <span class="built_in">string</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> test = test &amp; test1 <span class="comment">// 这是的test 是一个 &#x27;number &amp; string&#x27;   就是never</span></span><br></pre></td></tr></table></figure></li>
<li><p>多次定义表现不同<br>interface 可以定义多次， 多次的声明会合并<br>type定义多次会报错</p>
</li>
<li><p>计算属性<br>type 能使用’in’关键字 生成映射类型， 但interface 不可以</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> list = <span class="string">&#x27;first&#x27;</span> | <span class="string">&#x27;second&#x27;</span></span><br><span class="line"><span class="keyword">type</span> DubeType = &#123;</span><br><span class="line">    [key <span class="keyword">in</span> list] :<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> test:DubeType = &#123;</span><br><span class="line">    first: <span class="string">&#x27;11&#x27;</span>,</span><br><span class="line">    second: <span class="string">&#x27;22&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>抽象类<br>不具体的类，通常作为父类， 因为仅作为基类，不可以 new</p>
</li>
<li><p>.d.ts 作用</p>
<ul>
<li>处理引入外部的js库中js文件里变量的具体类型不明确的问题，为了告诉ts变量的类型， 所以定义.d.ts</li>
<li>为 ts 提供有关用 js 编写的 API 的类型信息</li>
<li>简单理解为在ts中调用js 的声明文件</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>近期面试题汇总</title>
    <url>/2022/05/22/%E8%BF%91%E6%9C%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ul>
<li>问：TCP为什么三次握手， 两次不行吗？<ul>
<li>答： 第一次确认客户端的发送能力  </li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>近期状态</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 11安装安卓应用</title>
    <url>/2021/12/04/win11%E5%AE%89%E8%A3%85%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>windows 11 发布已过3月， 终于是圆了发布会上说的安装安卓应用的饼， 当然不能直接点击apk文件安装，<br>需要一点骚操作</p>
<h2 id="Let-me-help-you"><a href="#Let-me-help-you" class="headerlink" title="Let me help you"></a>Let me help you</h2><hr>
<p>一、首先打开全新的win11 设置页面 点开更多windows 功能<br><img src="https://xiaoli-wyy.oss-cn-hongkong.aliyuncs.com/win%2011%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E6%95%99%E7%A8%8B%E5%9B%BE%E7%89%87/setting.png" alt="img"><br>勾选<code>Hyper-V</code>和<code>虚拟机平台</code>, 第一个只有windows 是专业版才有， 不是专业版咋办呢， 那就只勾选一个， 然后确定等待重启完成</p>
<hr>
<h2 id="二、再次开启电脑后，-让我们下载一个-在windows-控制安卓的主控程序（名字太长了读不好）"><a href="#二、再次开启电脑后，-让我们下载一个-在windows-控制安卓的主控程序（名字太长了读不好）" class="headerlink" title="二、再次开启电脑后， 让我们下载一个 在windows 控制安卓的主控程序（名字太长了读不好）"></a>二、再次开启电脑后， 让我们下载一个 在windows 控制安卓的主控程序（名字太长了读不好）</h2><p>百度网盘： <a href="https://pan.baidu.com/s/1KN3nCm8_992sAQoFGhVk8Q">https://pan.baidu.com/s/1KN3nCm8_992sAQoFGhVk8Q</a> 提取码: 4au8<br>or<br>直接点击 <a href="https://xiaoli-wyy.oss-cn-hongkong.aliyuncs.com/win%2011%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E6%95%99%E7%A8%8B%E5%9B%BE%E7%89%87/MicrosoftCorporationII.WindowsSubsystemForAndroid_1.7.32815.0_neutral___8wekyb3d8bbwe.Msixbundle">下载</a></p>
<hr>
<ul>
<li>让我们通过命令安装<ul>
<li>按下开始键输入 <code>powerShell</code></li>
<li>输入 <code>cd &#39;你下载好的软件所在位置&#39;</code></li>
<li>一般需要已管理员运行</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Add-AppxPackage <span class="string">&quot;文件所在的路径&quot;</span></span><br></pre></td></tr></table></figure>
<p>回车安装</p>
<h2 id="四、-安装成功后，有报错联系我，-没报错继续-首先点开开始键，-会发现多了一个-“推荐的项目”-Windows-Subsystem-for-Android-以下简称-WSA"><a href="#四、-安装成功后，有报错联系我，-没报错继续-首先点开开始键，-会发现多了一个-“推荐的项目”-Windows-Subsystem-for-Android-以下简称-WSA" class="headerlink" title="四、 安装成功后，有报错联系我， 没报错继续, 首先点开开始键， 会发现多了一个 “推荐的项目” Windows Subsystem for Android 以下简称 WSA"></a>四、 安装成功后，有报错联系我， 没报错继续, 首先点开开始键， 会发现多了一个 “推荐的项目” Windows Subsystem for Android 以下简称 WSA</h2><p>然后怎么安装安卓应用呢</p>
<ul>
<li>打开 WSA 打开开发者人员模式， 然后点击文件旁边的箭头<br>回到 WSA 会看见如下图<br><img src="https://xiaoli-wyy.oss-cn-hongkong.aliyuncs.com/win%2011%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E6%95%99%E7%A8%8B%E5%9B%BE%E7%89%87/wsa1.png" alt="img"></li>
</ul>
<p>然后我们需要安装安卓的控制程序，点击这个<a href="https://xiaoli-wyy.oss-cn-hongkong.aliyuncs.com/win%2011%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E6%95%99%E7%A8%8B%E5%9B%BE%E7%89%87/adb.zip">链接</a>下载</p>
<p>下载完成后,让我们打开系统盘（一般默认是C盘)<br>给里面两个文件拖放到这个文件夹下<br><img src="https://xiaoli-wyy.oss-cn-hongkong.aliyuncs.com/win%2011%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E6%95%99%E7%A8%8B%E5%9B%BE%E7%89%87/WSA2.png" alt="img">  </p>
<hr>
<p>然后让我们键盘键入win + r输入cmd， 然后一次窒执行以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">adb version <span class="comment">// 查看 是否能使用adb命令</span></span><br><span class="line"></span><br><span class="line">adb connect 开发者人员模式下面的访问地址</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后就可以 cd 到又apk的目录下， 或者直接复制apk文件所在的文件夹位置</span></span><br><span class="line">adb install <span class="string">&#x27;对应apk文件所在地址&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后就成功咯</span></span><br></pre></td></tr></table></figure>
<p>大概如下图：<img src="https://xiaoli-wyy.oss-cn-hongkong.aliyuncs.com/win%2011%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E6%95%99%E7%A8%8B%E5%9B%BE%E7%89%87/wsa3.png" alt="img"></p>
<hr>
<p>这样您就可以使用安卓应用啦， 甚至可以用鼠标打音游（（（（</p>
]]></content>
      <tags>
        <tag>win11 的小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>CapsLock+</title>
    <url>/2021/04/03/CapsLk/</url>
    <content><![CDATA[<hr>
<h3 id="实际上，-这里曾经是要写点啥的，-后来忙忘了（"><a href="#实际上，-这里曾经是要写点啥的，-后来忙忘了（" class="headerlink" title="实际上， 这里曾经是要写点啥的， 后来忙忘了（"></a>实际上， 这里曾经是要写点啥的， 后来忙忘了（</h3><h3 id="那大家不如直接百度搜索CapsLock-然后去看她的文档吧（（（-地址是：https-capslox-com-capslock-plus"><a href="#那大家不如直接百度搜索CapsLock-然后去看她的文档吧（（（-地址是：https-capslox-com-capslock-plus" class="headerlink" title="那大家不如直接百度搜索CapsLock++ 然后去看她的文档吧（（（ 地址是：https://capslox.com/capslock-plus/"></a>那大家不如直接百度搜索CapsLock++ 然后去看她的文档吧（（（ 地址是：<a href="https://capslox.com/capslock-plus/">https://capslox.com/capslock-plus/</a></h3>]]></content>
  </entry>
  <entry>
    <title>异步遍历器</title>
    <url>/2021/03/30/%E5%BC%82%E6%AD%A5%E9%81%8D%E5%8E%86%E5%99%A8/</url>
    <content><![CDATA[<h5 id="1-同步遍历器的问题"><a href="#1-同步遍历器的问题" class="headerlink" title="1. 同步遍历器的问题"></a>1. 同步遍历器的问题</h5><p>Iterator 接口是一种数据遍历的协议， 只要调用遍历器对想的next方法， 就会得到一个对象， 表示当前遍历指针所在的那个位置的信息。 next 方法返回的对象的结构时 {value, done}，其中value 表示当前的数据的值， done 时一个布尔值， 表示遍历是否结束。</p>
]]></content>
      <tags>
        <tag>ES6标准入门阅读总结</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构的扩展</title>
    <url>/2021/03/30/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%84%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h5 id="1-字符串"><a href="#1-字符串" class="headerlink" title="**1. 字符串 **"></a>**1. 字符串 **</h5><ul>
<li><code>``</code>表示模板字符串， 功能非常强大 可以当作普通字符串使用， 也可以用来定义多行字符串， 或者和在字符串中潜入变量。<br>如果使用模板字符串表示多行字符串， 所有的空格和缩进都会被保留在输出之中 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#list&#x27;</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">	&lt;ul&gt;</span></span><br><span class="line"><span class="string">		&lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string">		&lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">	&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure>
上面代码中， 所有模板字符串的空格和换行， 都是被保留的， 比如<code>&lt;ul&gt;</code> 标签前面会有一个换行， 如果你不想要换行， 可以使用trim 方法消除它。 模板字符串中嵌入变量， 需要将变量名写在${} 之中。 大括号内部可以放入任意的JavaScript 表达式， 可以进行运算，以及引入对象属性和调用属性。 例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span></span><br><span class="line"><span class="comment">//1+2 = 3</span></span><br></pre></td></tr></table></figure>
如果模板字符串中的变量没有声明， 将会报错。</li>
</ul>
<hr>
<ul>
<li><code>codePointAt </code>可作为 <code>charCodeAt </code>的代替品， 必要时使用 <code>for ...of</code> 遍历字符串， 他们都是为了处理 32位的 UTF-16 字符。</li>
</ul>
<p>正常写法： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;啊a&quot;</span></span><br><span class="line">s.length  <span class="comment">// 3 无法正确识别字符串长度， 会把 “啊” 识别为两个字符</span></span><br><span class="line">s.charAt(<span class="number">0</span>) <span class="comment">// charAt 无法处理这个 字</span></span><br><span class="line">s.charAt(<span class="number">1</span>) <span class="comment">// &#x27;&#x27;</span></span><br><span class="line">s.charCodeAt(<span class="number">0</span>) <span class="comment">// 55362 charCodeAt 只能两个字节，两个字节分开返回</span></span><br><span class="line">s.charCodeAt(<span class="number">1</span>) <span class="comment">// 57271</span></span><br></pre></td></tr></table></figure>
<p>es6 写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;啊a&#x27;</span></span><br><span class="line">s.codePointAt(<span class="number">0</span>) <span class="comment">// 134071 可以识别一整个字</span></span><br><span class="line">s.codePointAt(<span class="number">1</span>) <span class="comment">// 57271 第三， 四字节会被返回</span></span><br><span class="line">s.codePointAt(<span class="number">2</span>) <span class="comment">// 97 字符串长度仍有问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(ch.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 20BB7 134071 是10进制， 20bb7 为16进制表示</span></span><br><span class="line"><span class="comment">// 61 字符串长度也是没问题的， 循环执行了两次</span></span><br></pre></td></tr></table></figure>
<p>还有 <code>includes，startWith，endWith，padStart，padEnd </code>等方法</p>
<hr>
<h5 id="2-Number"><a href="#2-Number" class="headerlink" title="**2. Number **"></a>**2. Number **</h5><p><code>parseInt </code>等全局方法挂在到Number 上， 如 <code>Number.parseInt</code>,  <code>Number.parseFloat</code> 等, 增加了一些高阶计算函数。</p>
<h5 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a><strong>3. 函数</strong></h5><p>箭头函数， <code>this </code>的指向在函数生成时固定， 说白了就是<code>this </code>指向与外部一致。</p>
<hr>
<p>函数参数默认值 ， 在 《变量的解析赋值》一文中已有介绍。 补充： 设置某参数必须可以：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwNeedThisParamException</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">	thorw <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Missing parameter: <span class="subst">$&#123;param&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span> (<span class="params">x = throwNeedThisParamException(<span class="string">&#x27;x&#x27;</span>)</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数的默认值时在取不到值的情况下才会执行的， 所以蒸菜情况不会抛出 这个错误。</p>
<p>————————————<br>参数 的<code>rest </code>形式 如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dome</span> (<span class="params">...values</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(values)</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;=============&#x27;</span>)</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">dome(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="comment">// =============</span></span><br><span class="line"><span class="comment">//  [1,2,3,4, callee: (...), symbol(Symbol.iterator): f]</span></span><br></pre></td></tr></table></figure>
<p>内置的<code>argeuments </code>为类数组结构， 可以看见有一个 <code>Symbol </code>类型的字段 <code>Symbol.iterator </code>， 这是它的迭代器， 使其可以向数组一样遍历， 但如果展开看其 <code>_proto_</code>， 值为<code>Object</code>， 而使用 <code>rest </code>形式的参数， 可以直接将参数转换为数组， 注意rest 形式的参数之恶能用作最后一个参数。</p>
<hr>
<p>函数的<code>length</code> 属性返回函数参数的个数， <code>name </code>属性 返回声明的函数名称， ES6 的变量式声明返回变量名 、 如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">f1.name  <span class="comment">// f1</span></span><br><span class="line"><span class="keyword">const</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123;&#125;</span><br><span class="line">f2.name <span class="comment">// f2</span></span><br><span class="line">f2.length <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<hr>
<p>双冒号玉奴算符， 代替<code>bind，call， apply</code>绑定<code>this </code>对象指向。<code>foo::bar(arguments)</code>相当于 <code>bar.apply(foo, arguments)</code></p>
<hr>
<p>尾调用， 就是最后返回值为执行另一个函数<code> return anotherFunction()</code> , 而 <code>return anoherFunction() +1 </code>不属于尾调用， 因为在执行完<code>anotherFunction </code>后还需要<code>+1</code> 。 尾调用的又是就是在<code>return </code>后，可以释放当前函数执行所需要的一切资源空间。 对比下面两个例子， 是做 斐波那契数列 求值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;=<span class="number">1</span> ) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">Fibonacci(<span class="number">10</span>) <span class="comment">//89</span></span><br><span class="line">Fibonacci(<span class="number">100</span>) <span class="comment">//堆栈溢出</span></span><br><span class="line">Fibonacci(<span class="number">500</span>) <span class="comment">// 堆栈溢出</span></span><br></pre></td></tr></table></figure>
<p>这是最简单的写法， 清晰明了， 第n项就是前两项的和。 但是， 为了计算加号两边的值， 必须要保存函数执行的全部资源， 递归后造成堆栈溢出， 这不属于尾调用。 优化后如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci2</span> (<span class="params">n, a1 = <span class="number">1</span>, a2 = <span class="number">1</span></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> a2</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Fibonacci2( n-<span class="number">1</span> , a2, a1 + a2)</span><br><span class="line">&#125;</span><br><span class="line">Fibonacci2(<span class="number">100</span>) <span class="comment">//  573147844013817200000</span></span><br><span class="line">Fibonacci2(<span class="number">1000</span>) <span class="comment">//7.0330367711422765e+208</span></span><br><span class="line">Fibonacci2(<span class="number">10000</span>)<span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>
<p>优化过后的递归调用， <code>return </code>之后无需保存函数所需要的紫苑， 所以不会出现堆栈溢出， 只是在逻辑上不太好理解， 这种写法 <code>Fibonacci2 (n - 1, a2, a1 + a2) </code>可以看成 一个从前到后推导过程， <code>n </code>相当于一个计数器， 每次值得增长是通过两个数求和 <code>a1 + a2 </code>作为第二个数， <code>a2 </code>作为第一个数</p>
<hr>
<h5 id="4-数组"><a href="#4-数组" class="headerlink" title="**4. 数组 **"></a>**4. 数组 **</h5><p>扩展运算符<code>... </code>， 与上文得<code>rest </code>参数 是相反的用法,<br>rest 参数是把一个个的参数总和到数组rest 参数 中， 而扩展运算符是把数组中的元素一个个提取出来。<br>扩展运算符可以用来方便的复制一个数组。 如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(...arr) <span class="comment">// 相当于console.log(1,2,3)</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr] <span class="comment">// 相当于 let arr2 = [1,2,3]</span></span><br><span class="line">arr.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr2) <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>
<hr>
<p>数组可以通过<code>Array.from</code> ，<code>Array.of </code>生成， 可以通过<code>keys()</code>, <code>values()</code>,<code> entries()</code> 遍历。 <code>Array.from</code> 可以从具有<code>iterator</code> 的数据结构生成数组， 比如 <code>arguments </code>对象，<code>document.querySelectorAll()</code>获得的DOM 对象， 这些都是类数组， 或者 <code>Map</code>，<code>Set </code>等新增的数据结构。<br><code>Array.of</code> 可以代替<code>new Array() </code>， 因为 <code>new Array()</code> 的参数与行为不统一， 当传入一个参数且为数字时， 代表数组长度， <code>Array.of </code>不会有这个问题， 会通过参数创建数组。<br><code>Array </code>还新增了一些工具方法 比如：<code>find </code>, <code>findIndex</code>, <code>includes </code>等等</p>
<h5 id="5-对象"><a href="#5-对象" class="headerlink" title="5. 对象"></a><strong>5. 对象</strong></h5><p><code>Object.assign </code>是合并对象， 把多个对象合并到第一个对象上。<br><code>Object.create</code> 是以某原型， 生成一个新对象。 可选第二个参数， 为属性描述符， 使用方法如下代码。<br><code>Object.getPrototypeOf</code>, <code>Object.setPrototypeOf</code> 是获取和设置对想原型属性<code> _proto_</code> , 不应显式使用<code>_porto_</code>这个属性。<br><code>Object.getOwnPropertyDescriptors</code> 是获取对象的属性信息， 包括 <code>value </code>， <code>writable</code>， <code>enumerate</code>， <code>configurable</code>.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">const</span> source2  = &#123; <span class="attr">c</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2)</span><br><span class="line">target <span class="comment">//&#123;a: 1, b:2. c:3&#125;</span></span><br><span class="line">------------</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(target, &#123; <span class="attr">myProto</span>: <span class="string">&#x27;PROTO&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(target) <span class="comment">// &#123;myProto: &#x27;PROTO&#x27;, _proto_: Object&#125;</span></span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(target))</span><br><span class="line">newObj <span class="comment">// 无显式属性&#123;_proto_: &#123;myProto: &#x27;PROTO&#x27;, _proto_: Object&#125;&#125;</span></span><br><span class="line">----------------</span><br><span class="line"><span class="keyword">const</span> descriptors = <span class="built_in">Object</span>.getOwnProertyDescriptors(target)</span><br><span class="line"><span class="built_in">console</span>.log(descriptors)</span><br><span class="line">newObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(target), descriptors)</span><br><span class="line">newObj <span class="comment">//&#123; a: 1, b:2, c:3, _proto_: &#123;myProto: &#x27; PROTO&#x27;, _proto: Object&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>ES6 允许字面量定义对象时， 用表达式作为属性名， 把表达式放在方括号内 ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> propKey = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	[propKey]: <span class="literal">true</span></span><br><span class="line">	[<span class="string">&#x27;a&#x27;</span>+ <span class="string">&#x27;bc&#x27;</span>]:<span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line">obj <span class="comment">// &#123; foo: true, abc:123&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<p><code>Object.is </code>优化了<code> ===</code> 运算符 ， 处理了 <code>=== </code>的两个问题  如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>) <span class="comment">//true</span></span><br><span class="line">---------</span><br><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>,-<span class="number">0</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>ES6标准入门阅读总结</tag>
      </tags>
  </entry>
  <entry>
    <title>变量的解构赋值</title>
    <url>/2021/03/30/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<hr>
<h5 id="1-解构时分为匹配模式和被赋值的变量，-若相同可简写，-注意区分"><a href="#1-解构时分为匹配模式和被赋值的变量，-若相同可简写，-注意区分" class="headerlink" title="1. 解构时分为匹配模式和被赋值的变量， 若相同可简写， 注意区分"></a>1. 解构时分为匹配模式和被赋值的变量， 若相同可简写， 注意区分</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; matchValue &#125; = &#123; <span class="attr">matchValue</span>: <span class="number">123</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(matchValue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于 =</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">matchValue</span>: matchValue &#125; = &#123; <span class="attr">matchValue</span>: <span class="number">123</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(matchValue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以 ==</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">matchValue</span>: value &#125; = &#123; <span class="attr">matchValue</span>: <span class="number">123</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(matchValue) <span class="comment">// 报未定义错误， 只是匹配模式， 不会被赋值</span></span><br><span class="line"><span class="built_in">console</span>.log(value) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<h5 id="2-函数参数"><a href="#2-函数参数" class="headerlink" title="2. 函数参数"></a>2. 函数参数</h5><p>首先解构赋值允许指定默认值， 这为函数参数设置默认值提供基础</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组解构赋值的默认值</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>] <span class="comment">// x= &#x27;a&#x27;, y= &#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="string">&#x27;a&#x27;</span>, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;aa&#x27;</span>, <span class="literal">undefined</span>] <span class="comment">// x=&#x27;aa&#x27;, y=&#x27;b&#x27; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象解构赋值的默认值</span></span><br><span class="line"><span class="keyword">let</span> &#123; x, y = <span class="number">5</span>&#125; = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line">x<span class="comment">//1</span></span><br><span class="line">y<span class="comment">//5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>这里只讨论一下参数为<code>object</code> 类型时， 该如何设置默认值， 比如一些 options 的设置， 通过设置默认值， 可有效避免<code> var foo =options.foo || &#39;default foo&#39;;</code> 有三种形式， 注意这三种的区别： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ajax1 = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;type = <span class="string">&#x27;GET&#x27;</span>, dataType &#125; = &#123;&#125; </span>) </span>&#123;</span><br><span class="line">	<span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ajax2 = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;&#125; =&#123;type = <span class="string">&#x27;GET&#x27;</span>, dataType = <span class="string">&#x27;json&#x27;</span>&#125;</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ajax3 = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;type= <span class="string">&#x27;GET&#x27;</span>, dataType = <span class="string">&#x27;json&#x27;</span>&#125;</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>ajax1</code> 的默认参数表示， 如果没有传入<code>options</code> ，则用一个没有键值对的对象（） 作为默认值， 正应如此 ，传入的<code>options</code> 没有<code>options.type</code> 和 <code>options.dataType</code> 这两个属性， 则赋予默认值 <code>type = &#39;GET&#39; , dataType = &#39;json&#39;</code> ， 这是针对键值对某一个 <code>key</code>设默认值。</p>
</li>
<li><p><code>ajax2</code> 的默认参数表示， 如果没有传入<code>options</code> 对象， 则用一个 <code>&#123;type = &#39;GET&#39;, dataType = &#39;json&#39;&#125;</code> 这样的<code>options</code> 对象作为默认值， 这是争对一整个<code>options</code> 设默认值， 弊端就是如果开发者在使用时 这样写： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ajax2(url, &#123;type= <span class="string">&#x27;POST&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>那么 <code>dataType</code> 参数将要丢失， 因为<code>&#123;type = &#39;POST&#39;&#125;</code>代替了默认参数 <code>&#123; type = &#39;GET&#39;， dataType = ’JSON‘&#125;</code>,  所以一般通过形如<code>ajax1</code> 的方式定义默认参数。</p>
</li>
<li><p><code>ajax3</code> 的默认参数有一个问题， 就是当没有传入<code>options</code> 的时候， 相当于从<code>undefined</code> 中取值 <code>type, dataType</code> 来解构，<br>所以会报错。  就是这样 <code>ajax1</code> 才会通过<code>= &#123;&#125;</code>的方式， 把不传入<code>options</code> 的情况过滤掉。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>ES6标准入门阅读总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Symbol</title>
    <url>/2021/03/30/Symbol/</url>
    <content><![CDATA[<p><code>Symbol</code> 为不会重复的值， 第七种基本数据类型， 类似字符串， 可以作为对象的<code>key</code>， 但不会被<code>for...of</code> , <code>for...in</code>, <code>Object.getOwnPropertyNames()</code>, <code>Object.keys()</code> 返回， 如需遍历， 需使用<code>Object.getOwnPropertySymbols()</code>, 或者 <code>Reflect.ownKeys() </code>返回全部<code>Key</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> obj = &#123; [foo]: <span class="string">&#x27;foobar&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj)</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnProperTySymbols(obj)</span><br><span class="line"><span class="comment">// [Symbol(foo)]</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj)</span><br><span class="line"><span class="comment">// [Symbol(foo)]</span></span><br></pre></td></tr></table></figure>
<h5 id="1-Symbol-for-和-Symbol-keyFor"><a href="#1-Symbol-for-和-Symbol-keyFor" class="headerlink" title="1. Symbol.for() 和 Symbol.keyFor()"></a><strong>1. Symbol.for() 和 Symbol.keyFor()</strong></h5><ul>
<li><code>Symol </code>可以区确保生成的值不同， 但有时需要保存下来以便再次使用， 类似于单例， 如果存在就不会重新创建。 这时就需要使用 <code>Symbol.for()</code>。 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">s1 = s2 <span class="comment">// true</span></span><br><span class="line">s2 = s3 <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
从上面的代码可以看出,<code>Symbol.for</code>类似与将这个<code>Symbol</code> 等级, 所以<code>s1</code> 这个未登记的 <code>Symbol </code>不会等于其他<code>Symbol</code><br><code>Symbol.keyfor</code> 会返回已登记的 <code>Symbol </code>的 <code>key</code> , 一定是登记过的次啊会返回,  接上俐:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// undefiend</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="2-作为属性名的-Symbol"><a href="#2-作为属性名的-Symbol" class="headerlink" title="2. 作为属性名的 Symbol"></a><strong>2. 作为属性名的 Symbol</strong></h5><p>由于每一个 Symbol 值都是不相等的， 这意味着Symbol 值可以作为标识符， 用于对象的属性名， 就能保证不会出现同名属性， 这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line">	a[mySymbol] = <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">	[mySymbol]: <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProerty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">&#x27;Hello!&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后输出结果都是：</span></span><br><span class="line">a[mySymbol] <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过方括号结构 和Object.defineProperty， 将对象的属性名指定为一个Symbol 值。<br>当 Symbol 值作为对象属性名时， 不能用点运算符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;</span><br><span class="line">a.mySymbol = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">a[mySymbol] <span class="comment">// undefined</span></span><br><span class="line">a[<span class="string">&#x27;mySymbol&#x27;</span>] <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过上例 同理可得： Symbol 值定义属时， Symbol 值必须放在方括号之中。<br>Symbol还可以用于定义一组常量， 保证这组常量的值都是不相等的。 例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">const</span> log = &#123;&#125;</span><br><span class="line">log.levels = &#123;</span><br><span class="line">	DEBUG: <span class="built_in">Symbol</span>(<span class="string">&#x27;debug&#x27;</span>),</span><br><span class="line">	INFO: <span class="built_in">Symbol</span>(<span class="string">&#x27;info&#x27;</span>),</span><br><span class="line">	WARN: <span class="built_in">Symbol</span>(<span class="string">&#x27;warn&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(log.levels.DEBUG, <span class="string">&#x27;debug message&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(log.levels.INFO, <span class="string">&#x27;info message&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">const</span> COLOR_RED = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> COLOR_GREEN = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComplement</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(color) &#123;</span><br><span class="line">		<span class="keyword">case</span> COLOR_RED:</span><br><span class="line">			<span class="keyword">return</span> COLOR_GREEN</span><br><span class="line">		<span class="keyword">case</span> COLOR_GREEN:</span><br><span class="line">			<span class="keyword">return</span> COLOR_RED</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Undefined color&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量使用Symbol 值最大的好处， 就是其他任何值都不可能由相同的值了， 因此可以保证上面的switch 语句会按设计的方式工作。 当Symbol作为属性名时， 该属性是公开属性， 不是私有属性</p>
]]></content>
      <tags>
        <tag>ES6标准入门阅读总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxy 和 Reflect</title>
    <url>/2021/03/30/Proxy%E5%92%8CReflect/</url>
    <content><![CDATA[<p><code>Proxy </code>代理对象的各种内置方法, <code>get ``set ``construct </code>等, 类似于拦截器 .<br><code>Reflect </code>则作为 <code>Object </code>的代替者, <code>Object </code>上的一些静态方法被移植到了 <code>Reflect </code>上.<br><code>Reflect </code>对象一共有13个静态方法。</p>
<ul>
<li>Reflect.apply(target, thisArg, args)</li>
<li>Reflect.construct(target, args)</li>
<li>Reflect.get(target, name, receiver)</li>
<li>Reflect.set(target, name, value, receiver)</li>
<li>Reflect.defineProperty(target, name, desc)</li>
<li>Reflect.deleteProperty(target, name)</li>
<li>Reflect.has(target, name)</li>
<li>Reflect.ownKeys(target)</li>
<li>Reflect.preventExtensions(target)</li>
<li>Reflect.getOwnPropertyDescritptor(target, name)</li>
<li>Reflect.getPrototypeOf(target)</li>
<li>Reflect.setPrototypeOf(target)<br>通过 <code>Proxy </code>和 <code>Reflect  </code>可以实现观察者模式， 就是监听<code>set </code>方法，执行相应操作。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;Li&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">const</span> personObserved = observe(person)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;key&#125;</span> to <span class="subst">$&#123;value&#125;</span>!`</span>) <span class="string">`</span></span><br><span class="line"><span class="string">		return Reflect.set(target, key, value, receiver)</span></span><br><span class="line"><span class="string">	&#125;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">personObseved.name = &#x27;zhao&#x27;</span></span><br><span class="line"><span class="string">// setting name to zhao</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>ES6标准入门阅读总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2021/03/30/Promise/</url>
    <content><![CDATA[<p><code>Promise </code>用来处理异步操作， 是构建函数， 参数为 <code>then </code>和<code>catch </code>后需要执行的方法， 下面是使用 <code>Promise </code>封装的<code>ajax</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span>.readyState !==<span class="number">4</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">			resolve(<span class="built_in">this</span>.response)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">const</span> client = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        client.open(<span class="string">&#x27;GET&#x27;</span>, url)</span><br><span class="line">        client.onreadystatechange = handler</span><br><span class="line">        client.responseType = <span class="string">&#x27;json&#x27;</span></span><br><span class="line">        client.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">        client.send()</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br><span class="line">getJSON(<span class="string">&quot;/posts.json&quot;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;Contents: &#x27;</span> + json)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;错误&#x27;</span>, error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>ES6标准入门阅读总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Ierator 和 for ...of 循环</title>
    <url>/2021/03/30/Iterator%E5%92%8Cfor...of%20/</url>
    <content><![CDATA[<p><code>Iterator </code>被挂载在对象的 <code>Symbol.iterator</code> 属性下， <code>Symbol.iterator</code> 不是<code>Iterator</code>， 而是返回 <code>Iterator </code>的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">iterator <span class="comment">// Array Iterator &#123;&#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">----------</span><br><span class="line">iterator.next() <span class="comment">// &#123;value: 5, done: false&#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>ES6标准入门阅读总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Generator 和 yield</title>
    <url>/2021/03/30/Generator%20%E5%92%8C%20yield/</url>
    <content><![CDATA[<p><code>Generator </code>会生成一个 <code>Iterator </code>， 每次 <code>Iterator.next() </code>返回 <code>yield </code>的产出值， 且中断程序执行。 代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">yield</span> <span class="number">1</span>&#125;</span>`</span>)</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">yield</span> <span class="number">2</span>&#125;</span>`</span>)</span><br><span class="line">	<span class="keyword">yield</span>* demo2()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ite = demo()</span><br><span class="line">ite.next() <span class="comment">// 返回值： &#123;value: 1, done: false&#125;</span></span><br><span class="line">ite.next() <span class="comment">// console: undefined, 返回值：&#123;value: 2, done: false&#125;</span></span><br><span class="line">ite.next(<span class="number">123456789</span>) <span class="comment">//console: 123456789, 返回值： &#123;value: 3, done: false&#125;</span></span><br></pre></td></tr></table></figure>
<p>第一次<code>ite.next()</code> 时， 程序执行到<code>yield 1</code>被终止， 故没有打印日志， 再次执行<code> ite.next()</code> 时， 代码继续， 开始执行<code>console.log(&#39;$&#123;yield 1&#125;&#39;) </code> 但输出不是1 而是 <code>undefiend </code>，因为<code>ite.next()</code>的参数值会被当做上次<code>yield </code>语句的执行结果， 所以下面的<code>ite.next(123456789)</code> 会输出数字 <code>123456789</code></p>
]]></content>
      <tags>
        <tag>ES6标准入门阅读总结</tag>
      </tags>
  </entry>
  <entry>
    <title>const 和 let</title>
    <url>/2021/03/30/const%20%E5%92%8C%20let/</url>
    <content><![CDATA[<p>测试<br><img src="https://cdn.jsdelivr.net/gh/XiaoLi-sach/source@main/images/cover1.jpg," alt="好家伙" title="初音"></p>
<hr>
<h5 id="1-暂时性死区"><a href="#1-暂时性死区" class="headerlink" title="1. 暂时性死区"></a><strong>1. 暂时性死区</strong></h5><ul>
<li><p><code>let 和 const</code> 命令声明的变量五变量提升， 在命令执行前， 使用该变量都将报错， 这一部分成为‘‘暂时性死区‘’</p>
</li>
<li><p><code>let tmp</code> 将<code>tmp</code> 变量绑定到 <code>&#123;&#125;</code> 代码块之内， 外部的<code>tmp </code>声明无效，<code> tmp = ‘abc’</code> 就处在死去， 所以报错。 同理在以前没有 let 和 <code>const </code>命令的时候， <code>typeof </code>是一个安全的运算符， 即使变量没有被声明， 也会正常返回 <code>undefined </code>， 但如果<code>typeof</code>处在死区中， 处理后了在后文被<code>let </code>和 <code>const </code>的变量 将会报错。</p>
</li>
</ul>
<hr>
<h5 id="2-顶层对象"><a href="#2-顶层对象" class="headerlink" title="2. 顶层对象"></a><strong>2. 顶层对象</strong></h5><ul>
<li>var 和 function 的全局声明会自动绑定到 window 或 global 对象， 这是 es 5 全局变量的一个缺陷， let 和 const 不会、</li>
</ul>
<hr>
<h5 id="3-const-命令"><a href="#3-const-命令" class="headerlink" title="3. const 命令"></a><strong>3. const 命令</strong></h5><ul>
<li>const 声明的变量只是引用无法修改， 对象的内部结构可以改变， 使用 Object.freeze() 可以彻底锁定某对象， 需递归锁定多层级对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">      constantize(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>ES6标准入门阅读总结</tag>
      </tags>
  </entry>
  <entry>
    <title>async</title>
    <url>/2021/03/30/async%20%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h5 id="1-含义"><a href="#1-含义" class="headerlink" title="1. 含义"></a><strong>1. 含义</strong></h5><p><code>async</code> 使 异步操作变得更加方便。 本质上就是 <code>Generator</code> 函数的语法糖。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">		fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">			resolve(data)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/hello&#x27;</span>)</span><br><span class="line">		<span class="built_in">console</span>.log(f1.toString())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 <code>gen</code> 写成 <code>async</code>函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">&#x27;/etc/hello&#x27;</span>)</span><br><span class="line">	<span class="built_in">console</span>.log(f1.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较后可知： <code>async</code> 函数就是将<code>Generator</code> 函数的（<code>*</code>） 替换成了 <code>async</code> ， 将<code>yield</code> 替换成了 <code>await</code></p>
<h5 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2. 基本用法"></a><strong>2. 基本用法</strong></h5><p><code>async </code>函数返回一个 <code>Promise </code>对象， 可以使用<code>then </code>方法添加回调函数。 当函数执行的时候， 一旦遇到<code>await </code>就会先返回， 等到异步操作完成， 再接着执行函数体后面的语句。 例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStockPriceByName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> symbol = <span class="keyword">await</span> getStockSymbol(name)</span><br><span class="line"> <span class="keyword">const</span> stockPrice = <span class="keyword">await</span> getStockPrice(symbol)</span><br><span class="line"> <span class="keyword">return</span> stockPrice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName(<span class="string">&#x27;goog&#x27;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面代码 函数前面的<code>async </code>关键字， 表明该函数内部有异步操作， 调用该函数时， 会立即返回一个<code>Promise </code>对象，</p>
<p>下面这个例子 指定多少毫秒后输出一个值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(resolve, ms)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">await</span> timeout(ms)</span><br><span class="line">	<span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line">asyncPrint(<span class="string">&#x27;hello world&#x27;</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<p>以上代码代表 50毫秒后， 输出<code>hello world</code>， 用 <code>async </code>函数后 如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(resolve, ms)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">await</span> timeout(ms)</span><br><span class="line">	<span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line">asyncPrint(<span class="string">&#x27;hello world&#x27;</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<h5 id="3-await-命令"><a href="#3-await-命令" class="headerlink" title="3. await 命令"></a><strong>3. await 命令</strong></h5><p>正常情况下， <code>await </code>命令后面是一个 <code>Promise </code>对象， 返回该对象的结果。 如果不是 <code>Promise </code>对象， 就直接返回对应的值。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span> <span class="comment">// 等同于 return 123</span></span><br><span class="line">&#125;</span><br><span class="line">f().then( v = &gt; <span class="built_in">console</span>.log(v)) <span class="comment">//123</span></span><br></pre></td></tr></table></figure>
<p>另一种情况是， <code>await</code>命令后面是一个<code>thenable </code>对象 （即定义了<code>then </code>方法的对象），那么<code>await </code>会将其等同于<code>Promise </code>对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sleep</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">timeout</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.timeout = timeout</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">then</span>(<span class="params">resolve, reject</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> startTime = <span class="built_in">Date</span>.now()</span><br><span class="line">		setTiemout(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">			resolve(<span class="built_in">Date</span>.now() - startTime),</span><br><span class="line">			<span class="built_in">this</span>.timeout</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> sleepTime = <span class="keyword">await</span> <span class="keyword">new</span> Sleep(<span class="number">1000</span>)</span><br><span class="line">	<span class="built_in">console</span>.log(sleepTime)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>
<p>上面代码中， <code>await </code>命令后面是一个 <code>Sleep </code>对象的实例， 这个例子不是<code>Promise </code>对象， 但是因为定义了 <code>then </code>方法， <code>await </code>会将其视为 <code>Promise </code>处理。 还演示了如何实现休眠效果， JavaScript 一直没有休眠的方法， 但是借助了await 命令就可以让程序停顿指定的时间。简化后：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">interval</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(resolve, interval)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 </span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">one2FiveInAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i)</span><br><span class="line">		<span class="keyword">await</span> sleep(<span class="number">1000</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">one2FiveInAsync()</span><br></pre></td></tr></table></figure>
<p><code>await </code>命令后面的<code>Promise </code>对象 如果变为<code>reject </code>状态， 则 <code>reject </code>的参数会被<code>catch </code>方法的回调函数接收到。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v)).catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br></pre></td></tr></table></figure>
<p>任何一个<code>await </code>语句后面的<code>Promise </code>对象变为<code>reject </code>状态， 那么整个<code>async</code> 函数都会中断执行。 如果 希望即使第一个异步操作失败， 也不要中断后面的异步操作， 这时 可以将第一个<code>await</code> 放在<code>try ...catch</code> 结构里面， 这样不管这个异步操作是否成功， 第二个<code>await </code>都会执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;错误&#x27;</span>)</span><br><span class="line">	&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br></pre></td></tr></table></figure>
<h5 id="4-顶层await"><a href="#4-顶层await" class="headerlink" title="4. 顶层await"></a><strong>4. 顶层await</strong></h5><p>根据语法规格， <code>await </code>命令只能出现在<code>async </code>函数内部， 否则都会报错。</p>
<p>借用<code>await </code>解决模块异步加载问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//awaiting.js</span></span><br><span class="line"><span class="keyword">let</span> output</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> dynamic = <span class="keyword">await</span> <span class="keyword">import</span>(someMission)</span><br><span class="line">	<span class="keyword">const</span> data = <span class="keyword">await</span> fetch(url)</span><br><span class="line">	output = someProcess(dynameic.default, data)</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line"><span class="keyword">export</span> &#123; output &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中， 模块<code>awaiting.js </code>的输出值 <code>output </code>， 取决于异步操作， 把异步操作都执行， 变量 <code>output </code>才会有值， 否则就会返回 <code>undefined</code>， 将上面代码写成立即执行函数形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// awaiting.js</span></span><br><span class="line"><span class="keyword">let</span> output</span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> dynamic = <span class="keyword">await</span> <span class="keyword">import</span>(someMission)</span><br><span class="line">	<span class="keyword">const</span> data = <span class="keyword">await</span> fetch(url)</span><br><span class="line">	output = someProcess(dynamic.default, data)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">export</span> &#123; output &#125;</span><br></pre></td></tr></table></figure>
<p>加载这个模块的写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usage.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; output &#125; <span class="keyword">from</span> <span class="string">&#x27;./awaiting.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputPlusValue</span>(<span class="params">Value</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> output + value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(outputPlusValue(<span class="number">100</span>))</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(outputPlusValue(<span class="number">100</span>), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>outputPlusValue() </code>的执行结果， 完全取决于执行的时间。 如果<code> awaiting.js</code> 里面的异步操作没执行完， 加载进来的output 的值就是<code>undefined</code></p>
<p>目前解决方法， 就是让原始模块输出一个<code>Promise </code>对象， 从这个<code>Promise </code>对象判断异步操作有没有结束</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  awaiting.js</span></span><br><span class="line"><span class="keyword">let</span> output</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> dynamic = <span class="keyword">await</span> <span class="keyword">import</span>(someMission)</span><br><span class="line">	<span class="keyword">const</span> data = <span class="keyword">await</span> fetch(url)</span><br><span class="line">	output = someProcess(dynamic.default, data)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">export</span> &#123; output &#125;</span><br></pre></td></tr></table></figure>
<p><code>awaiting.js </code>除了输出<code>output </code>， 还默认输出一个<code>Promise </code>对象 （<code>async </code>函数立即执行后， 返回一个<code>Promise </code>对象）， 从这个对象判断异步操作是否结束。 由此新写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usage.js</span></span><br><span class="line"><span class="keyword">import</span> promise, &#123; output &#125; <span class="keyword">from</span> <span class="string">&#x27;./awaiting.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputPlusValue</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> output + value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(outputPlusValue(<span class="number">100</span>))</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(outputPlusValue(<span class="number">100</span>), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面代码中， 将 <code>awaiting.js</code>  对象的输出， 放在<code>promise.then()</code> 里面， 这样就能保证异步操作完成后， 才去读取 <code>output</code>。 会发现这种写法比较麻烦， 等于要求模块的使用者蹲守一个额外的使用协议， 按照特殊的方法使用这个模块。 一旦你忘了要用<code>promise </code>加载， 只使用正常的加载方法， 依赖这个模块的代码就可能出错， 而且， 如果上面的 <code>useage.js</code> 又有对外的输出， 等于这个依赖链的所有模块都要使用 <code>Promise </code>加载.</p>
<p>顶层的 <code>await </code>命令， 就是为了解决这个问题，它保证只有异步操作完成， 模块才会输出值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// awaiting.js</span></span><br><span class="line"><span class="keyword">const</span> dynamic = <span class="keyword">import</span>(someMission)</span><br><span class="line"><span class="keyword">const</span> data = fetch(url)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> output = someProcess((<span class="keyword">await</span> dynamic).default, <span class="keyword">await</span> data)</span><br></pre></td></tr></table></figure>
<p>上面代码中， 两个异步操作在输出的时候， 都加上<code>await </code>命令， 只有等到异步操作完成， 这个模块才会输出值。<br>加载这个模块的写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usage.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; output &#125; <span class="keyword">from</span> <span class="string">&#x27;./awaiting.js&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputPlusValue</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> output * value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(outputPlusValue(<span class="number">100</span>))</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(outputPlusValue(<span class="number">100</span>), <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码的写法， 与普通的模块加载完全一样。   也就是说， 模块的使用者完全不用关心， 依赖模块的内部有没有异步操作， 正常加载即可。</p>
<p>这时， 模块的加载会等待依赖模块（上例是 <code>awaiting.js</code>）的异步操作完成， 才执行后面的代码， 有点像暂停在那里。 所以， 它总是会得到正确的<code>output</code>, 不会因为加载时机不同，而得到不一样的值。</p>
<p>一些顶层<code>await </code>的使用场景</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import() 方法加载</span></span><br><span class="line"><span class="keyword">const</span> strings = <span class="keyword">await</span>  <span class="keyword">import</span>(<span class="string">&#x27;/i18n/$&#123;navigator.language/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库操作</span></span><br><span class="line"><span class="keyword">const</span> connection = <span class="keyword">await</span> dbConnector()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖回滚</span></span><br><span class="line"><span class="keyword">let</span> jQuery</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	jQuery = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;========&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">	jQuery = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;====&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意， 如果加载多个宝海顶层<code>await </code>命令的模块， 加载命令是同步执行的。</p>
]]></content>
      <tags>
        <tag>ES6标准入门阅读总结</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机 MacOS教程</title>
    <url>/2020/12/26/Mac%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="实际上这里也是准备写点啥的，-但也是忙忘了"><a href="#实际上这里也是准备写点啥的，-但也是忙忘了" class="headerlink" title="实际上这里也是准备写点啥的， 但也是忙忘了"></a>实际上这里也是准备写点啥的， 但也是忙忘了</h3><p>线上观看地址：<a href="https://www.bilibili.com/video/BV1RV411a7Jk/">https://www.bilibili.com/video/BV1RV411a7Jk/</a></p>
]]></content>
      <tags>
        <tag>MacOS</tag>
      </tags>
  </entry>
</search>
