{"title":"async","slug":"async 函数","date":"2021-03-30T10:49:59.549Z","updated":"2021-03-30T11:24:03.541Z","comments":true,"excerpt":"","content":"<h5 id=\"1-含义\"><a href=\"#1-含义\" class=\"headerlink\" title=\"1. 含义\"></a><strong>1. 含义</strong></h5><p><code>async</code> 使 异步操作变得更加方便。 本质上就是 <code>Generator</code> 函数的语法糖。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> readFile = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fileName</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">\t\tfs.readFile(fileName, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, data</span>) </span>&#123;</span><br><span class=\"line\">\t\t\tresolve(data)</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">const</span> f1 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">&#x27;/etc/hello&#x27;</span>)</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(f1.toString())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的 <code>gen</code> 写成 <code>async</code>函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> asyncReadFile = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> f1 = <span class=\"keyword\">await</span> readFile(<span class=\"string\">&#x27;/etc/hello&#x27;</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(f1.toString())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>比较后可知： <code>async</code> 函数就是将<code>Generator</code> 函数的（<code>*</code>） 替换成了 <code>async</code> ， 将<code>yield</code> 替换成了 <code>await</code></p>\n<h5 id=\"2-基本用法\"><a href=\"#2-基本用法\" class=\"headerlink\" title=\"2. 基本用法\"></a><strong>2. 基本用法</strong></h5><p><code>async </code>函数返回一个 <code>Promise </code>对象， 可以使用<code>then </code>方法添加回调函数。 当函数执行的时候， 一旦遇到<code>await </code>就会先返回， 等到异步操作完成， 再接着执行函数体后面的语句。 例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getStockPriceByName</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> symbol = <span class=\"keyword\">await</span> getStockSymbol(name)</span><br><span class=\"line\"> <span class=\"keyword\">const</span> stockPrice = <span class=\"keyword\">await</span> getStockPrice(symbol)</span><br><span class=\"line\"> <span class=\"keyword\">return</span> stockPrice</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getStockPriceByName(<span class=\"string\">&#x27;goog&#x27;</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(result)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>上面代码 函数前面的<code>async </code>关键字， 表明该函数内部有异步操作， 调用该函数时， 会立即返回一个<code>Promise </code>对象，</p>\n<p>下面这个例子 指定多少毫秒后输出一个值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">setTimeout</span>(resolve, ms)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncPrint</span>(<span class=\"params\">value, ms</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">await</span> timeout(ms)</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">asyncPrint(<span class=\"string\">&#x27;hello world&#x27;</span>, <span class=\"number\">50</span>)</span><br></pre></td></tr></table></figure>\n<p>以上代码代表 50毫秒后， 输出<code>hello world</code>， 用 <code>async </code>函数后 如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">setTimeout</span>(resolve, ms)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncPrint</span>(<span class=\"params\">value, ms</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">await</span> timeout(ms)</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">asyncPrint(<span class=\"string\">&#x27;hello world&#x27;</span>, <span class=\"number\">50</span>)</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-await-命令\"><a href=\"#3-await-命令\" class=\"headerlink\" title=\"3. await 命令\"></a><strong>3. await 命令</strong></h5><p>正常情况下， <code>await </code>命令后面是一个 <code>Promise </code>对象， 返回该对象的结果。 如果不是 <code>Promise </code>对象， 就直接返回对应的值。 </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"number\">123</span> <span class=\"comment\">// 等同于 return 123</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f().then( v = &gt; <span class=\"built_in\">console</span>.log(v)) <span class=\"comment\">//123</span></span><br></pre></td></tr></table></figure>\n<p>另一种情况是， <code>await</code>命令后面是一个<code>thenable </code>对象 （即定义了<code>then </code>方法的对象），那么<code>await </code>会将其等同于<code>Promise </code>对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sleep</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">timeout</span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.timeout = timeout</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">then</span>(<span class=\"params\">resolve, reject</span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">const</span> startTime = <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\">\t\tsetTiemout(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">\t\t\tresolve(<span class=\"built_in\">Date</span>.now() - startTime),</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">this</span>.timeout</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">(<span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> sleepTime = <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> Sleep(<span class=\"number\">1000</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(sleepTime)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 1000</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中， <code>await </code>命令后面是一个 <code>Sleep </code>对象的实例， 这个例子不是<code>Promise </code>对象， 但是因为定义了 <code>then </code>方法， <code>await </code>会将其视为 <code>Promise </code>处理。 还演示了如何实现休眠效果， JavaScript 一直没有休眠的方法， 但是借助了await 命令就可以让程序停顿指定的时间。简化后：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sleep</span>(<span class=\"params\">interval</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">setTimeout</span>(resolve, interval)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 </span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">one2FiveInAsync</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">await</span> sleep(<span class=\"number\">1000</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">one2FiveInAsync()</span><br></pre></td></tr></table></figure>\n<p><code>await </code>命令后面的<code>Promise </code>对象 如果变为<code>reject </code>状态， 则 <code>reject </code>的参数会被<code>catch </code>方法的回调函数接收到。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">&#x27;出错了&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f().then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v)).catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e))</span><br></pre></td></tr></table></figure>\n<p>任何一个<code>await </code>语句后面的<code>Promise </code>对象变为<code>reject </code>状态， 那么整个<code>async</code> 函数都会中断执行。 如果 希望即使第一个异步操作失败， 也不要中断后面的异步操作， 这时 可以将第一个<code>await</code> 放在<code>try ...catch</code> 结构里面， 这样不管这个异步操作是否成功， 第二个<code>await </code>都会执行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">&#x27;错误&#x27;</span>)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span>(e) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">&#x27;hello world&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f().then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br></pre></td></tr></table></figure>\n<h5 id=\"4-顶层await\"><a href=\"#4-顶层await\" class=\"headerlink\" title=\"4. 顶层await\"></a><strong>4. 顶层await</strong></h5><p>根据语法规格， <code>await </code>命令只能出现在<code>async </code>函数内部， 否则都会报错。</p>\n<p>借用<code>await </code>解决模块异步加载问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//awaiting.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> output</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> dynamic = <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(someMission)</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> fetch(url)</span><br><span class=\"line\">\toutput = someProcess(dynameic.default, data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">main()</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; output &#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中， 模块<code>awaiting.js </code>的输出值 <code>output </code>， 取决于异步操作， 把异步操作都执行， 变量 <code>output </code>才会有值， 否则就会返回 <code>undefined</code>， 将上面代码写成立即执行函数形式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// awaiting.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> output</span><br><span class=\"line\">(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> dynamic = <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(someMission)</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> fetch(url)</span><br><span class=\"line\">\toutput = someProcess(dynamic.default, data)</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; output &#125;</span><br></pre></td></tr></table></figure>\n<p>加载这个模块的写法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// usage.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; output &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./awaiting.js&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outputPlusValue</span>(<span class=\"params\">Value</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> output + value</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(outputPlusValue(<span class=\"number\">100</span>))</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(outputPlusValue(<span class=\"number\">100</span>), <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><code>outputPlusValue() </code>的执行结果， 完全取决于执行的时间。 如果<code> awaiting.js</code> 里面的异步操作没执行完， 加载进来的output 的值就是<code>undefined</code></p>\n<p>目前解决方法， 就是让原始模块输出一个<code>Promise </code>对象， 从这个<code>Promise </code>对象判断异步操作有没有结束</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  awaiting.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> output</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> dynamic = <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(someMission)</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> fetch(url)</span><br><span class=\"line\">\toutput = someProcess(dynamic.default, data)</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; output &#125;</span><br></pre></td></tr></table></figure>\n<p><code>awaiting.js </code>除了输出<code>output </code>， 还默认输出一个<code>Promise </code>对象 （<code>async </code>函数立即执行后， 返回一个<code>Promise </code>对象）， 从这个对象判断异步操作是否结束。 由此新写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// usage.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> promise, &#123; output &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./awaiting.js&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outputPlusValue</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> output + value</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(outputPlusValue(<span class=\"number\">100</span>))</span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(outputPlusValue(<span class=\"number\">100</span>), <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>上面代码中， 将 <code>awaiting.js</code>  对象的输出， 放在<code>promise.then()</code> 里面， 这样就能保证异步操作完成后， 才去读取 <code>output</code>。 会发现这种写法比较麻烦， 等于要求模块的使用者蹲守一个额外的使用协议， 按照特殊的方法使用这个模块。 一旦你忘了要用<code>promise </code>加载， 只使用正常的加载方法， 依赖这个模块的代码就可能出错， 而且， 如果上面的 <code>useage.js</code> 又有对外的输出， 等于这个依赖链的所有模块都要使用 <code>Promise </code>加载.</p>\n<p>顶层的 <code>await </code>命令， 就是为了解决这个问题，它保证只有异步操作完成， 模块才会输出值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// awaiting.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> dynamic = <span class=\"keyword\">import</span>(someMission)</span><br><span class=\"line\"><span class=\"keyword\">const</span> data = fetch(url)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> output = someProcess((<span class=\"keyword\">await</span> dynamic).default, <span class=\"keyword\">await</span> data)</span><br></pre></td></tr></table></figure>\n<p>上面代码中， 两个异步操作在输出的时候， 都加上<code>await </code>命令， 只有等到异步操作完成， 这个模块才会输出值。<br>加载这个模块的写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// usage.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; output &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./awaiting.js&#x27;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outputPlusValue</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> output * value</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(outputPlusValue(<span class=\"number\">100</span>))</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(outputPlusValue(<span class=\"number\">100</span>), <span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure>\n<p>上面代码的写法， 与普通的模块加载完全一样。   也就是说， 模块的使用者完全不用关心， 依赖模块的内部有没有异步操作， 正常加载即可。</p>\n<p>这时， 模块的加载会等待依赖模块（上例是 <code>awaiting.js</code>）的异步操作完成， 才执行后面的代码， 有点像暂停在那里。 所以， 它总是会得到正确的<code>output</code>, 不会因为加载时机不同，而得到不一样的值。</p>\n<p>一些顶层<code>await </code>的使用场景</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// import() 方法加载</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> strings = <span class=\"keyword\">await</span>  <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;/i18n/$&#123;navigator.language/&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数据库操作</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> connection = <span class=\"keyword\">await</span> dbConnector()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 依赖回滚</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> jQuery</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\tjQuery = <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;========&#x27;</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">\tjQuery = <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;====&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意， 如果加载多个宝海顶层<code>await </code>命令的模块， 加载命令是同步执行的。</p>\n","categories":[],"tags":[{"name":"ES6标准入门阅读总结","path":"api/tags/ES6标准入门阅读总结.json"}]}