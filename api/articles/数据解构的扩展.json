{"title":"数据结构的扩展","slug":"数据解构的扩展","date":"2021-03-30T10:49:59.566Z","updated":"2021-03-30T11:23:38.099Z","comments":true,"excerpt":"","content":"<h5 id=\"1-字符串\"><a href=\"#1-字符串\" class=\"headerlink\" title=\"**1. 字符串 **\"></a>**1. 字符串 **</h5><ul>\n<li><code>``</code>表示模板字符串， 功能非常强大 可以当作普通字符串使用， 也可以用来定义多行字符串， 或者和在字符串中潜入变量。<br>如果使用模板字符串表示多行字符串， 所有的空格和缩进都会被保留在输出之中 <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">&#x27;#list&#x27;</span>).html(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">\t&lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">\t\t&lt;li&gt;first&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">\t\t&lt;li&gt;second&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">\t&lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">`</span>);</span><br></pre></td></tr></table></figure>\n上面代码中， 所有模板字符串的空格和换行， 都是被保留的， 比如<code>&lt;ul&gt;</code> 标签前面会有一个换行， 如果你不想要换行， 可以使用trim 方法消除它。 模板字符串中嵌入变量， 需要将变量名写在${} 之中。 大括号内部可以放入任意的JavaScript 表达式， 可以进行运算，以及引入对象属性和调用属性。 例：<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"string\">`<span class=\"subst\">$&#123;x&#125;</span> + <span class=\"subst\">$&#123;y&#125;</span> = <span class=\"subst\">$&#123;x + y&#125;</span>`</span></span><br><span class=\"line\"><span class=\"comment\">//1+2 = 3</span></span><br></pre></td></tr></table></figure>\n如果模板字符串中的变量没有声明， 将会报错。</li>\n</ul>\n<hr>\n<ul>\n<li><code>codePointAt </code>可作为 <code>charCodeAt </code>的代替品， 必要时使用 <code>for ...of</code> 遍历字符串， 他们都是为了处理 32位的 UTF-16 字符。</li>\n</ul>\n<p>正常写法： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">&quot;啊a&quot;</span></span><br><span class=\"line\">s.length  <span class=\"comment\">// 3 无法正确识别字符串长度， 会把 “啊” 识别为两个字符</span></span><br><span class=\"line\">s.charAt(<span class=\"number\">0</span>) <span class=\"comment\">// charAt 无法处理这个 字</span></span><br><span class=\"line\">s.charAt(<span class=\"number\">1</span>) <span class=\"comment\">// &#x27;&#x27;</span></span><br><span class=\"line\">s.charCodeAt(<span class=\"number\">0</span>) <span class=\"comment\">// 55362 charCodeAt 只能两个字节，两个字节分开返回</span></span><br><span class=\"line\">s.charCodeAt(<span class=\"number\">1</span>) <span class=\"comment\">// 57271</span></span><br></pre></td></tr></table></figure>\n<p>es6 写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">&#x27;啊a&#x27;</span></span><br><span class=\"line\">s.codePointAt(<span class=\"number\">0</span>) <span class=\"comment\">// 134071 可以识别一整个字</span></span><br><span class=\"line\">s.codePointAt(<span class=\"number\">1</span>) <span class=\"comment\">// 57271 第三， 四字节会被返回</span></span><br><span class=\"line\">s.codePointAt(<span class=\"number\">2</span>) <span class=\"comment\">// 97 字符串长度仍有问题</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> ch <span class=\"keyword\">of</span> s) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(ch.codePointAt(<span class=\"number\">0</span>).toString(<span class=\"number\">16</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 20BB7 134071 是10进制， 20bb7 为16进制表示</span></span><br><span class=\"line\"><span class=\"comment\">// 61 字符串长度也是没问题的， 循环执行了两次</span></span><br></pre></td></tr></table></figure>\n<p>还有 <code>includes，startWith，endWith，padStart，padEnd </code>等方法</p>\n<hr>\n<h5 id=\"2-Number\"><a href=\"#2-Number\" class=\"headerlink\" title=\"**2. Number **\"></a>**2. Number **</h5><p><code>parseInt </code>等全局方法挂在到Number 上， 如 <code>Number.parseInt</code>,  <code>Number.parseFloat</code> 等, 增加了一些高阶计算函数。</p>\n<h5 id=\"3-函数\"><a href=\"#3-函数\" class=\"headerlink\" title=\"3. 函数\"></a><strong>3. 函数</strong></h5><p>箭头函数， <code>this </code>的指向在函数生成时固定， 说白了就是<code>this </code>指向与外部一致。</p>\n<hr>\n<p>函数参数默认值 ， 在 《变量的解析赋值》一文中已有介绍。 补充： 设置某参数必须可以：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throwNeedThisParamException</span>(<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">\tthorw <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Missing parameter: <span class=\"subst\">$&#123;param&#125;</span>`</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">demo</span> (<span class=\"params\">x = throwNeedThisParamException(<span class=\"string\">&#x27;x&#x27;</span>)</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参数的默认值时在取不到值的情况下才会执行的， 所以蒸菜情况不会抛出 这个错误。</p>\n<p>————————————<br>参数 的<code>rest </code>形式 如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dome</span> (<span class=\"params\">...values</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(values)</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;=============&#x27;</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dome(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\">// [1,2,3,4]</span></span><br><span class=\"line\"><span class=\"comment\">// =============</span></span><br><span class=\"line\"><span class=\"comment\">//  [1,2,3,4, callee: (...), symbol(Symbol.iterator): f]</span></span><br></pre></td></tr></table></figure>\n<p>内置的<code>argeuments </code>为类数组结构， 可以看见有一个 <code>Symbol </code>类型的字段 <code>Symbol.iterator </code>， 这是它的迭代器， 使其可以向数组一样遍历， 但如果展开看其 <code>_proto_</code>， 值为<code>Object</code>， 而使用 <code>rest </code>形式的参数， 可以直接将参数转换为数组， 注意rest 形式的参数之恶能用作最后一个参数。</p>\n<hr>\n<p>函数的<code>length</code> 属性返回函数参数的个数， <code>name </code>属性 返回声明的函数名称， ES6 的变量式声明返回变量名 、 如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">f1.name  <span class=\"comment\">// f1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> f2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x,y</span>) </span>&#123;&#125;</span><br><span class=\"line\">f2.name <span class=\"comment\">// f2</span></span><br><span class=\"line\">f2.length <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<hr>\n<p>双冒号玉奴算符， 代替<code>bind，call， apply</code>绑定<code>this </code>对象指向。<code>foo::bar(arguments)</code>相当于 <code>bar.apply(foo, arguments)</code></p>\n<hr>\n<p>尾调用， 就是最后返回值为执行另一个函数<code> return anotherFunction()</code> , 而 <code>return anoherFunction() +1 </code>不属于尾调用， 因为在执行完<code>anotherFunction </code>后还需要<code>+1</code> 。 尾调用的又是就是在<code>return </code>后，可以释放当前函数执行所需要的一切资源空间。 对比下面两个例子， 是做 斐波那契数列 求值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fibonacci</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;=<span class=\"number\">1</span> ) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Fibonacci(n - <span class=\"number\">1</span>) + Fibonacci(n - <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fibonacci(<span class=\"number\">10</span>) <span class=\"comment\">//89</span></span><br><span class=\"line\">Fibonacci(<span class=\"number\">100</span>) <span class=\"comment\">//堆栈溢出</span></span><br><span class=\"line\">Fibonacci(<span class=\"number\">500</span>) <span class=\"comment\">// 堆栈溢出</span></span><br></pre></td></tr></table></figure>\n<p>这是最简单的写法， 清晰明了， 第n项就是前两项的和。 但是， 为了计算加号两边的值， 必须要保存函数执行的全部资源， 递归后造成堆栈溢出， 这不属于尾调用。 优化后如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fibonacci2</span> (<span class=\"params\">n, a1 = <span class=\"number\">1</span>, a2 = <span class=\"number\">1</span></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a2</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Fibonacci2( n-<span class=\"number\">1</span> , a2, a1 + a2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fibonacci2(<span class=\"number\">100</span>) <span class=\"comment\">//  573147844013817200000</span></span><br><span class=\"line\">Fibonacci2(<span class=\"number\">1000</span>) <span class=\"comment\">//7.0330367711422765e+208</span></span><br><span class=\"line\">Fibonacci2(<span class=\"number\">10000</span>)<span class=\"comment\">// Infinity</span></span><br></pre></td></tr></table></figure>\n<p>优化过后的递归调用， <code>return </code>之后无需保存函数所需要的紫苑， 所以不会出现堆栈溢出， 只是在逻辑上不太好理解， 这种写法 <code>Fibonacci2 (n - 1, a2, a1 + a2) </code>可以看成 一个从前到后推导过程， <code>n </code>相当于一个计数器， 每次值得增长是通过两个数求和 <code>a1 + a2 </code>作为第二个数， <code>a2 </code>作为第一个数</p>\n<hr>\n<h5 id=\"4-数组\"><a href=\"#4-数组\" class=\"headerlink\" title=\"**4. 数组 **\"></a>**4. 数组 **</h5><p>扩展运算符<code>... </code>， 与上文得<code>rest </code>参数 是相反的用法,<br>rest 参数是把一个个的参数总和到数组rest 参数 中， 而扩展运算符是把数组中的元素一个个提取出来。<br>扩展运算符可以用来方便的复制一个数组。 如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(...arr) <span class=\"comment\">// 相当于console.log(1,2,3)</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = [...arr] <span class=\"comment\">// 相当于 let arr2 = [1,2,3]</span></span><br><span class=\"line\">arr.push(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2) <span class=\"comment\">// [1,2,3]</span></span><br></pre></td></tr></table></figure>\n<hr>\n<p>数组可以通过<code>Array.from</code> ，<code>Array.of </code>生成， 可以通过<code>keys()</code>, <code>values()</code>,<code> entries()</code> 遍历。 <code>Array.from</code> 可以从具有<code>iterator</code> 的数据结构生成数组， 比如 <code>arguments </code>对象，<code>document.querySelectorAll()</code>获得的DOM 对象， 这些都是类数组， 或者 <code>Map</code>，<code>Set </code>等新增的数据结构。<br><code>Array.of</code> 可以代替<code>new Array() </code>， 因为 <code>new Array()</code> 的参数与行为不统一， 当传入一个参数且为数字时， 代表数组长度， <code>Array.of </code>不会有这个问题， 会通过参数创建数组。<br><code>Array </code>还新增了一些工具方法 比如：<code>find </code>, <code>findIndex</code>, <code>includes </code>等等</p>\n<h5 id=\"5-对象\"><a href=\"#5-对象\" class=\"headerlink\" title=\"5. 对象\"></a><strong>5. 对象</strong></h5><p><code>Object.assign </code>是合并对象， 把多个对象合并到第一个对象上。<br><code>Object.create</code> 是以某原型， 生成一个新对象。 可选第二个参数， 为属性描述符， 使用方法如下代码。<br><code>Object.getPrototypeOf</code>, <code>Object.setPrototypeOf</code> 是获取和设置对想原型属性<code> _proto_</code> , 不应显式使用<code>_porto_</code>这个属性。<br><code>Object.getOwnPropertyDescriptors</code> 是获取对象的属性信息， 包括 <code>value </code>， <code>writable</code>， <code>enumerate</code>， <code>configurable</code>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> source1 = &#123; <span class=\"attr\">b</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> source2  = &#123; <span class=\"attr\">c</span>: <span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(target, source1, source2)</span><br><span class=\"line\">target <span class=\"comment\">//&#123;a: 1, b:2. c:3&#125;</span></span><br><span class=\"line\">------------</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(target, &#123; <span class=\"attr\">myProto</span>: <span class=\"string\">&#x27;PROTO&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(target) <span class=\"comment\">// &#123;myProto: &#x27;PROTO&#x27;, _proto_: Object&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> newObj = <span class=\"built_in\">Object</span>.create(<span class=\"built_in\">Object</span>.getPrototypeOf(target))</span><br><span class=\"line\">newObj <span class=\"comment\">// 无显式属性&#123;_proto_: &#123;myProto: &#x27;PROTO&#x27;, _proto_: Object&#125;&#125;</span></span><br><span class=\"line\">----------------</span><br><span class=\"line\"><span class=\"keyword\">const</span> descriptors = <span class=\"built_in\">Object</span>.getOwnProertyDescriptors(target)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(descriptors)</span><br><span class=\"line\">newObj = <span class=\"built_in\">Object</span>.create(<span class=\"built_in\">Object</span>.getPrototypeOf(target), descriptors)</span><br><span class=\"line\">newObj <span class=\"comment\">//&#123; a: 1, b:2, c:3, _proto_: &#123;myProto: &#x27; PROTO&#x27;, _proto: Object&#125;&#125;</span></span><br></pre></td></tr></table></figure>\n<hr>\n<p>ES6 允许字面量定义对象时， 用表达式作为属性名， 把表达式放在方括号内 ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> propKey = <span class=\"string\">&#x27;foo&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">\t[propKey]: <span class=\"literal\">true</span></span><br><span class=\"line\">\t[<span class=\"string\">&#x27;a&#x27;</span>+ <span class=\"string\">&#x27;bc&#x27;</span>]:<span class=\"number\">123</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj <span class=\"comment\">// &#123; foo: true, abc:123&#125;</span></span><br></pre></td></tr></table></figure>\n<hr>\n<p><code>Object.is </code>优化了<code> ===</code> 运算符 ， 处理了 <code>=== </code>的两个问题  如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span> <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>,<span class=\"literal\">NaN</span>) <span class=\"comment\">//true</span></span><br><span class=\"line\">---------</span><br><span class=\"line\">+<span class=\"number\">0</span> === -<span class=\"number\">0</span> <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.is(+<span class=\"number\">0</span>,-<span class=\"number\">0</span>) <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>","categories":[],"tags":[{"name":"ES6标准入门阅读总结","path":"api/tags/ES6标准入门阅读总结.json"}]}